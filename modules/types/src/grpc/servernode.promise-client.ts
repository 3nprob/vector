// @generated by protobuf-ts 2.0.0-alpha.12 with parameters server_grpc1,client_promise,generate_dependencies
// @generated from protobuf file "servernode.proto" (package "com.vector", syntax proto3)
// tslint:disable
import { RpcTransport } from "@protobuf-ts/runtime-rpc";
import { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { ServerNodeService } from "./servernode";
import { EthProviderReply } from "./servernode";
import { EthProviderRequest } from "./servernode";
import { WithdrawalReconciledPayload } from "./servernode";
import { WithdrawalCreatedPayload } from "./servernode";
import { RequestCollateralPayload } from "./servernode";
import { DepositReconciledPayload } from "./servernode";
import { ConditionalTransferCreatedPayload } from "./servernode";
import { SetupPayload } from "./servernode";
import { RpcOutputStreamController } from "@protobuf-ts/runtime-rpc";
import { IsAlivePayload } from "./servernode";
import { TransferRequest } from "./servernode";
import { RestoreStateRequest } from "./servernode";
import { WithdrawRequest } from "./servernode";
import { ResolveTransferRequest } from "./servernode";
import { ConditionalTransferRequest } from "./servernode";
import { TxHash } from "./servernode";
import { DepositTxRequest } from "./servernode";
import { DepositRequest } from "./servernode";
import { SetupRequest } from "./servernode";
import { CreateNodeReply } from "./servernode";
import { CreateNodeRequest } from "./servernode";
import { ClearStoreRequest } from "./servernode";
import { RegisteredTransfers } from "./servernode";
import { RegisteredTransfersRequest } from "./servernode";
import { ActiveTransfersRequest } from "./servernode";
import { FullTransferStates } from "./servernode";
import { TransferStatesByRoutingIdRequest } from "./servernode";
import { TransferStateByRoutingIdRequest } from "./servernode";
import { FullTransferState } from "./servernode";
import { TransfersRequest } from "./servernode";
import { ChannelStateByParticipantsRequest } from "./servernode";
import { FullChannelStates } from "./servernode";
import { FullChannelState } from "./servernode";
import { ChannelStateRequest } from "./servernode";
import { RouterConfig } from "./servernode";
import { GetRouterConfigRequest } from "./servernode";
import { Status } from "./servernode";
import { GenericPublicIdentifierRequest } from "./servernode";
import { Configs } from "./servernode";
import { GenericMessageResponse } from "./servernode";
import { Empty } from "./servernode";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Server Node Service
 * Describes the Vector Server Node's interface
 *
 * @generated from protobuf service com.vector.ServerNodeService
 */
export interface IServerNodeServiceClient {
    /**
     * general metadata getters
     *
     * @generated from protobuf rpc: GetPing(com.vector.Empty) returns (com.vector.GenericMessageResponse);
     */
    getPing(input: Empty, options?: RpcOptions): Promise<GenericMessageResponse>;
    /**
     * @generated from protobuf rpc: GetConfig(com.vector.Empty) returns (com.vector.Configs);
     */
    getConfig(input: Empty, options?: RpcOptions): Promise<Configs>;
    /**
     * @generated from protobuf rpc: GetStatus(com.vector.GenericPublicIdentifierRequest) returns (com.vector.Status);
     */
    getStatus(input: GenericPublicIdentifierRequest, options?: RpcOptions): Promise<Status>;
    /**
     * @generated from protobuf rpc: GetRouterConfig(com.vector.GetRouterConfigRequest) returns (com.vector.RouterConfig);
     */
    getRouterConfig(input: GetRouterConfigRequest, options?: RpcOptions): Promise<RouterConfig>;
    /**
     * channel and transfer state getters
     *
     * @generated from protobuf rpc: GetChannelState(com.vector.ChannelStateRequest) returns (com.vector.FullChannelState);
     */
    getChannelState(input: ChannelStateRequest, options?: RpcOptions): Promise<FullChannelState>;
    /**
     * @generated from protobuf rpc: GetChannelStates(com.vector.Empty) returns (com.vector.FullChannelStates);
     */
    getChannelStates(input: Empty, options?: RpcOptions): Promise<FullChannelStates>;
    /**
     * @generated from protobuf rpc: GetChannelStateByParticipants(com.vector.ChannelStateByParticipantsRequest) returns (com.vector.FullChannelState);
     */
    getChannelStateByParticipants(input: ChannelStateByParticipantsRequest, options?: RpcOptions): Promise<FullChannelState>;
    /**
     * @generated from protobuf rpc: GetTransferState(com.vector.TransfersRequest) returns (com.vector.FullTransferState);
     */
    getTransferState(input: TransfersRequest, options?: RpcOptions): Promise<FullTransferState>;
    /**
     * @generated from protobuf rpc: GetTransferStateByRoutingId(com.vector.TransferStateByRoutingIdRequest) returns (com.vector.FullTransferState);
     */
    getTransferStateByRoutingId(input: TransferStateByRoutingIdRequest, options?: RpcOptions): Promise<FullTransferState>;
    /**
     * @generated from protobuf rpc: GetTransferStatesByRoutingId(com.vector.TransferStatesByRoutingIdRequest) returns (com.vector.FullTransferStates);
     */
    getTransferStatesByRoutingId(input: TransferStatesByRoutingIdRequest, options?: RpcOptions): Promise<FullTransferStates>;
    /**
     * @generated from protobuf rpc: GetActiveTransfers(com.vector.ActiveTransfersRequest) returns (com.vector.FullTransferStates);
     */
    getActiveTransfers(input: ActiveTransfersRequest, options?: RpcOptions): Promise<FullTransferStates>;
    /**
     * @generated from protobuf rpc: GetRegisteredTransfers(com.vector.RegisteredTransfersRequest) returns (com.vector.RegisteredTransfers);
     */
    getRegisteredTransfers(input: RegisteredTransfersRequest, options?: RpcOptions): Promise<RegisteredTransfers>;
    /**
     * external interface for server node functionality
     *
     * @generated from protobuf rpc: ClearStore(com.vector.ClearStoreRequest) returns (com.vector.Empty);
     */
    clearStore(input: ClearStoreRequest, options?: RpcOptions): Promise<Empty>;
    /**
     * @generated from protobuf rpc: CreateNode(com.vector.CreateNodeRequest) returns (com.vector.CreateNodeReply);
     */
    createNode(input: CreateNodeRequest, options?: RpcOptions): Promise<CreateNodeReply>;
    /**
     * @generated from protobuf rpc: Setup(com.vector.SetupRequest) returns (com.vector.FullChannelState);
     */
    setup(input: SetupRequest, options?: RpcOptions): Promise<FullChannelState>;
    /**
     * @generated from protobuf rpc: InternalSetup(com.vector.SetupRequest) returns (com.vector.FullChannelState);
     */
    internalSetup(input: SetupRequest, options?: RpcOptions): Promise<FullChannelState>;
    /**
     * @generated from protobuf rpc: Deposit(com.vector.DepositRequest) returns (com.vector.FullChannelState);
     */
    deposit(input: DepositRequest, options?: RpcOptions): Promise<FullChannelState>;
    /**
     * @generated from protobuf rpc: SendDepositTx(com.vector.DepositTxRequest) returns (com.vector.TxHash);
     */
    sendDepositTx(input: DepositTxRequest, options?: RpcOptions): Promise<TxHash>;
    /**
     * @generated from protobuf rpc: SendRequestCollateral(com.vector.DepositRequest) returns (com.vector.FullChannelState);
     */
    sendRequestCollateral(input: DepositRequest, options?: RpcOptions): Promise<FullChannelState>;
    /**
     * @generated from protobuf rpc: CreateTransfer(com.vector.ConditionalTransferRequest) returns (com.vector.FullChannelState);
     */
    createTransfer(input: ConditionalTransferRequest, options?: RpcOptions): Promise<FullChannelState>;
    /**
     * @generated from protobuf rpc: ResolveTransfer(com.vector.ResolveTransferRequest) returns (com.vector.FullChannelState);
     */
    resolveTransfer(input: ResolveTransferRequest, options?: RpcOptions): Promise<FullChannelState>;
    /**
     * @generated from protobuf rpc: Withdraw(com.vector.WithdrawRequest) returns (com.vector.FullChannelState);
     */
    withdraw(input: WithdrawRequest, options?: RpcOptions): Promise<FullChannelState>;
    /**
     * @generated from protobuf rpc: RestoreState(com.vector.RestoreStateRequest) returns (com.vector.FullChannelState);
     */
    restoreState(input: RestoreStateRequest, options?: RpcOptions): Promise<FullChannelState>;
    /**
     * dispute methods
     *
     * @generated from protobuf rpc: SendDisputeChannelTx(com.vector.ChannelStateRequest) returns (com.vector.TxHash);
     */
    sendDisputeChannelTx(input: ChannelStateRequest, options?: RpcOptions): Promise<TxHash>;
    /**
     * @generated from protobuf rpc: SendDefundChannelTx(com.vector.ChannelStateRequest) returns (com.vector.TxHash);
     */
    sendDefundChannelTx(input: ChannelStateRequest, options?: RpcOptions): Promise<TxHash>;
    /**
     * @generated from protobuf rpc: SendDisputeTransfer(com.vector.TransferRequest) returns (com.vector.TxHash);
     */
    sendDisputeTransfer(input: TransferRequest, options?: RpcOptions): Promise<TxHash>;
    /**
     * @generated from protobuf rpc: SendDefundTransfer(com.vector.TransferRequest) returns (com.vector.TxHash);
     */
    sendDefundTransfer(input: TransferRequest, options?: RpcOptions): Promise<TxHash>;
    /**
     * subscriptions - server to client stream
     *
     * @generated from protobuf rpc: IsAliveStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.IsAlivePayload);
     */
    isAliveStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<IsAlivePayload>;
    /**
     * @generated from protobuf rpc: SetupStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.SetupPayload);
     */
    setupStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<SetupPayload>;
    /**
     * @generated from protobuf rpc: ConditionalTransferCreatedStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.ConditionalTransferCreatedPayload);
     */
    conditionalTransferCreatedStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<ConditionalTransferCreatedPayload>;
    /**
     * @generated from protobuf rpc: ConditionalTransferResolvedStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.ConditionalTransferCreatedPayload);
     */
    conditionalTransferResolvedStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<ConditionalTransferCreatedPayload>;
    /**
     * @generated from protobuf rpc: DepositReconciledStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.DepositReconciledPayload);
     */
    depositReconciledStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<DepositReconciledPayload>;
    /**
     * @generated from protobuf rpc: RequestCollateralStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.RequestCollateralPayload);
     */
    requestCollateralStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<RequestCollateralPayload>;
    /**
     * @generated from protobuf rpc: WithdrawalCreatedStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.WithdrawalCreatedPayload);
     */
    withdrawalCreatedStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<WithdrawalCreatedPayload>;
    /**
     * @generated from protobuf rpc: WithdrawalResolvedStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.WithdrawalCreatedPayload);
     */
    withdrawalResolvedStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<WithdrawalCreatedPayload>;
    /**
     * @generated from protobuf rpc: WithdrawalReconciledStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.WithdrawalReconciledPayload);
     */
    withdrawalReconciledStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<WithdrawalReconciledPayload>;
    /**
     * @generated from protobuf rpc: RestoreStateStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.SetupPayload);
     */
    restoreStateStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<SetupPayload>;
    /**
     * eth provider pass-through
     *
     * @generated from protobuf rpc: EthProvider(com.vector.EthProviderRequest) returns (com.vector.EthProviderReply);
     */
    ethProvider(input: EthProviderRequest, options?: RpcOptions): Promise<EthProviderReply>;
}
/**
 * Server Node Service
 * Describes the Vector Server Node's interface
 *
 * @generated from protobuf service com.vector.ServerNodeService
 */
export class ServerNodeServiceClient implements IServerNodeServiceClient, ServiceInfo {
    typeName = ServerNodeService.typeName;
    methods = ServerNodeService.methods;
    options = ServerNodeService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * general metadata getters
     *
     * @generated from protobuf rpc: GetPing(com.vector.Empty) returns (com.vector.GenericMessageResponse);
     */
    getPing(input: Empty, options?: RpcOptions): Promise<GenericMessageResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<Empty, GenericMessageResponse>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetConfig(com.vector.Empty) returns (com.vector.Configs);
     */
    getConfig(input: Empty, options?: RpcOptions): Promise<Configs> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<Empty, Configs>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetStatus(com.vector.GenericPublicIdentifierRequest) returns (com.vector.Status);
     */
    getStatus(input: GenericPublicIdentifierRequest, options?: RpcOptions): Promise<Status> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<GenericPublicIdentifierRequest, Status>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetRouterConfig(com.vector.GetRouterConfigRequest) returns (com.vector.RouterConfig);
     */
    getRouterConfig(input: GetRouterConfigRequest, options?: RpcOptions): Promise<RouterConfig> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<GetRouterConfigRequest, RouterConfig>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * channel and transfer state getters
     *
     * @generated from protobuf rpc: GetChannelState(com.vector.ChannelStateRequest) returns (com.vector.FullChannelState);
     */
    getChannelState(input: ChannelStateRequest, options?: RpcOptions): Promise<FullChannelState> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ChannelStateRequest, FullChannelState>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetChannelStates(com.vector.Empty) returns (com.vector.FullChannelStates);
     */
    getChannelStates(input: Empty, options?: RpcOptions): Promise<FullChannelStates> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<Empty, FullChannelStates>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetChannelStateByParticipants(com.vector.ChannelStateByParticipantsRequest) returns (com.vector.FullChannelState);
     */
    getChannelStateByParticipants(input: ChannelStateByParticipantsRequest, options?: RpcOptions): Promise<FullChannelState> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ChannelStateByParticipantsRequest, FullChannelState>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetTransferState(com.vector.TransfersRequest) returns (com.vector.FullTransferState);
     */
    getTransferState(input: TransfersRequest, options?: RpcOptions): Promise<FullTransferState> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<TransfersRequest, FullTransferState>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetTransferStateByRoutingId(com.vector.TransferStateByRoutingIdRequest) returns (com.vector.FullTransferState);
     */
    getTransferStateByRoutingId(input: TransferStateByRoutingIdRequest, options?: RpcOptions): Promise<FullTransferState> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<TransferStateByRoutingIdRequest, FullTransferState>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetTransferStatesByRoutingId(com.vector.TransferStatesByRoutingIdRequest) returns (com.vector.FullTransferStates);
     */
    getTransferStatesByRoutingId(input: TransferStatesByRoutingIdRequest, options?: RpcOptions): Promise<FullTransferStates> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<TransferStatesByRoutingIdRequest, FullTransferStates>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetActiveTransfers(com.vector.ActiveTransfersRequest) returns (com.vector.FullTransferStates);
     */
    getActiveTransfers(input: ActiveTransfersRequest, options?: RpcOptions): Promise<FullTransferStates> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ActiveTransfersRequest, FullTransferStates>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetRegisteredTransfers(com.vector.RegisteredTransfersRequest) returns (com.vector.RegisteredTransfers);
     */
    getRegisteredTransfers(input: RegisteredTransfersRequest, options?: RpcOptions): Promise<RegisteredTransfers> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<RegisteredTransfersRequest, RegisteredTransfers>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * external interface for server node functionality
     *
     * @generated from protobuf rpc: ClearStore(com.vector.ClearStoreRequest) returns (com.vector.Empty);
     */
    clearStore(input: ClearStoreRequest, options?: RpcOptions): Promise<Empty> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ClearStoreRequest, Empty>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: CreateNode(com.vector.CreateNodeRequest) returns (com.vector.CreateNodeReply);
     */
    createNode(input: CreateNodeRequest, options?: RpcOptions): Promise<CreateNodeReply> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<CreateNodeRequest, CreateNodeReply>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: Setup(com.vector.SetupRequest) returns (com.vector.FullChannelState);
     */
    setup(input: SetupRequest, options?: RpcOptions): Promise<FullChannelState> {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<SetupRequest, FullChannelState>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: InternalSetup(com.vector.SetupRequest) returns (com.vector.FullChannelState);
     */
    internalSetup(input: SetupRequest, options?: RpcOptions): Promise<FullChannelState> {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<SetupRequest, FullChannelState>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: Deposit(com.vector.DepositRequest) returns (com.vector.FullChannelState);
     */
    deposit(input: DepositRequest, options?: RpcOptions): Promise<FullChannelState> {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<DepositRequest, FullChannelState>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: SendDepositTx(com.vector.DepositTxRequest) returns (com.vector.TxHash);
     */
    sendDepositTx(input: DepositTxRequest, options?: RpcOptions): Promise<TxHash> {
        const method = this.methods[17], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<DepositTxRequest, TxHash>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: SendRequestCollateral(com.vector.DepositRequest) returns (com.vector.FullChannelState);
     */
    sendRequestCollateral(input: DepositRequest, options?: RpcOptions): Promise<FullChannelState> {
        const method = this.methods[18], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<DepositRequest, FullChannelState>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: CreateTransfer(com.vector.ConditionalTransferRequest) returns (com.vector.FullChannelState);
     */
    createTransfer(input: ConditionalTransferRequest, options?: RpcOptions): Promise<FullChannelState> {
        const method = this.methods[19], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ConditionalTransferRequest, FullChannelState>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: ResolveTransfer(com.vector.ResolveTransferRequest) returns (com.vector.FullChannelState);
     */
    resolveTransfer(input: ResolveTransferRequest, options?: RpcOptions): Promise<FullChannelState> {
        const method = this.methods[20], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ResolveTransferRequest, FullChannelState>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: Withdraw(com.vector.WithdrawRequest) returns (com.vector.FullChannelState);
     */
    withdraw(input: WithdrawRequest, options?: RpcOptions): Promise<FullChannelState> {
        const method = this.methods[21], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<WithdrawRequest, FullChannelState>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: RestoreState(com.vector.RestoreStateRequest) returns (com.vector.FullChannelState);
     */
    restoreState(input: RestoreStateRequest, options?: RpcOptions): Promise<FullChannelState> {
        const method = this.methods[22], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<RestoreStateRequest, FullChannelState>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * dispute methods
     *
     * @generated from protobuf rpc: SendDisputeChannelTx(com.vector.ChannelStateRequest) returns (com.vector.TxHash);
     */
    sendDisputeChannelTx(input: ChannelStateRequest, options?: RpcOptions): Promise<TxHash> {
        const method = this.methods[23], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ChannelStateRequest, TxHash>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: SendDefundChannelTx(com.vector.ChannelStateRequest) returns (com.vector.TxHash);
     */
    sendDefundChannelTx(input: ChannelStateRequest, options?: RpcOptions): Promise<TxHash> {
        const method = this.methods[24], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ChannelStateRequest, TxHash>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: SendDisputeTransfer(com.vector.TransferRequest) returns (com.vector.TxHash);
     */
    sendDisputeTransfer(input: TransferRequest, options?: RpcOptions): Promise<TxHash> {
        const method = this.methods[25], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<TransferRequest, TxHash>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: SendDefundTransfer(com.vector.TransferRequest) returns (com.vector.TxHash);
     */
    sendDefundTransfer(input: TransferRequest, options?: RpcOptions): Promise<TxHash> {
        const method = this.methods[26], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<TransferRequest, TxHash>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * subscriptions - server to client stream
     *
     * @generated from protobuf rpc: IsAliveStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.IsAlivePayload);
     */
    isAliveStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<IsAlivePayload> {
        const method = this.methods[27], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<GenericPublicIdentifierRequest, IsAlivePayload>("serverStreaming", this._transport, method, opt, input);
        const stream = new RpcOutputStreamController<IsAlivePayload>();
        call.response.onNext(stream.notifyNext.bind(stream));
        call.status.catch(e => stream.closed || stream.notifyError(e));
        return stream;
    }
    /**
     * @generated from protobuf rpc: SetupStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.SetupPayload);
     */
    setupStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<SetupPayload> {
        const method = this.methods[28], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<GenericPublicIdentifierRequest, SetupPayload>("serverStreaming", this._transport, method, opt, input);
        const stream = new RpcOutputStreamController<SetupPayload>();
        call.response.onNext(stream.notifyNext.bind(stream));
        call.status.catch(e => stream.closed || stream.notifyError(e));
        return stream;
    }
    /**
     * @generated from protobuf rpc: ConditionalTransferCreatedStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.ConditionalTransferCreatedPayload);
     */
    conditionalTransferCreatedStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<ConditionalTransferCreatedPayload> {
        const method = this.methods[29], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<GenericPublicIdentifierRequest, ConditionalTransferCreatedPayload>("serverStreaming", this._transport, method, opt, input);
        const stream = new RpcOutputStreamController<ConditionalTransferCreatedPayload>();
        call.response.onNext(stream.notifyNext.bind(stream));
        call.status.catch(e => stream.closed || stream.notifyError(e));
        return stream;
    }
    /**
     * @generated from protobuf rpc: ConditionalTransferResolvedStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.ConditionalTransferCreatedPayload);
     */
    conditionalTransferResolvedStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<ConditionalTransferCreatedPayload> {
        const method = this.methods[30], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<GenericPublicIdentifierRequest, ConditionalTransferCreatedPayload>("serverStreaming", this._transport, method, opt, input);
        const stream = new RpcOutputStreamController<ConditionalTransferCreatedPayload>();
        call.response.onNext(stream.notifyNext.bind(stream));
        call.status.catch(e => stream.closed || stream.notifyError(e));
        return stream;
    }
    /**
     * @generated from protobuf rpc: DepositReconciledStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.DepositReconciledPayload);
     */
    depositReconciledStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<DepositReconciledPayload> {
        const method = this.methods[31], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<GenericPublicIdentifierRequest, DepositReconciledPayload>("serverStreaming", this._transport, method, opt, input);
        const stream = new RpcOutputStreamController<DepositReconciledPayload>();
        call.response.onNext(stream.notifyNext.bind(stream));
        call.status.catch(e => stream.closed || stream.notifyError(e));
        return stream;
    }
    /**
     * @generated from protobuf rpc: RequestCollateralStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.RequestCollateralPayload);
     */
    requestCollateralStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<RequestCollateralPayload> {
        const method = this.methods[32], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<GenericPublicIdentifierRequest, RequestCollateralPayload>("serverStreaming", this._transport, method, opt, input);
        const stream = new RpcOutputStreamController<RequestCollateralPayload>();
        call.response.onNext(stream.notifyNext.bind(stream));
        call.status.catch(e => stream.closed || stream.notifyError(e));
        return stream;
    }
    /**
     * @generated from protobuf rpc: WithdrawalCreatedStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.WithdrawalCreatedPayload);
     */
    withdrawalCreatedStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<WithdrawalCreatedPayload> {
        const method = this.methods[33], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<GenericPublicIdentifierRequest, WithdrawalCreatedPayload>("serverStreaming", this._transport, method, opt, input);
        const stream = new RpcOutputStreamController<WithdrawalCreatedPayload>();
        call.response.onNext(stream.notifyNext.bind(stream));
        call.status.catch(e => stream.closed || stream.notifyError(e));
        return stream;
    }
    /**
     * @generated from protobuf rpc: WithdrawalResolvedStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.WithdrawalCreatedPayload);
     */
    withdrawalResolvedStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<WithdrawalCreatedPayload> {
        const method = this.methods[34], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<GenericPublicIdentifierRequest, WithdrawalCreatedPayload>("serverStreaming", this._transport, method, opt, input);
        const stream = new RpcOutputStreamController<WithdrawalCreatedPayload>();
        call.response.onNext(stream.notifyNext.bind(stream));
        call.status.catch(e => stream.closed || stream.notifyError(e));
        return stream;
    }
    /**
     * @generated from protobuf rpc: WithdrawalReconciledStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.WithdrawalReconciledPayload);
     */
    withdrawalReconciledStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<WithdrawalReconciledPayload> {
        const method = this.methods[35], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<GenericPublicIdentifierRequest, WithdrawalReconciledPayload>("serverStreaming", this._transport, method, opt, input);
        const stream = new RpcOutputStreamController<WithdrawalReconciledPayload>();
        call.response.onNext(stream.notifyNext.bind(stream));
        call.status.catch(e => stream.closed || stream.notifyError(e));
        return stream;
    }
    /**
     * @generated from protobuf rpc: RestoreStateStream(com.vector.GenericPublicIdentifierRequest) returns (stream com.vector.SetupPayload);
     */
    restoreStateStream(input: GenericPublicIdentifierRequest, options?: RpcOptions): AsyncIterable<SetupPayload> {
        const method = this.methods[36], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<GenericPublicIdentifierRequest, SetupPayload>("serverStreaming", this._transport, method, opt, input);
        const stream = new RpcOutputStreamController<SetupPayload>();
        call.response.onNext(stream.notifyNext.bind(stream));
        call.status.catch(e => stream.closed || stream.notifyError(e));
        return stream;
    }
    /**
     * eth provider pass-through
     *
     * @generated from protobuf rpc: EthProvider(com.vector.EthProviderRequest) returns (com.vector.EthProviderReply);
     */
    ethProvider(input: EthProviderRequest, options?: RpcOptions): Promise<EthProviderReply> {
        const method = this.methods[37], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<EthProviderRequest, EthProviderReply>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
}
