// @generated by protobuf-ts 2.0.0-alpha.11 with parameters server_grpc,client_promise,generate_dependencies,optimize_code_size
// @generated from protobuf file "servernode.proto" (package "com.vector", syntax proto3)
// tslint:disable
import { RpcTransport } from "@protobuf-ts/runtime-rpc";
import { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { ServerNodeService } from "./servernode";
import { EthProviderReply } from "./servernode";
import { EthProviderRequest } from "./servernode";
import { CreateNodeReply } from "./servernode";
import { CreateNodeRequest } from "./servernode";
import { ClearStoreReply } from "./servernode";
import { ClearStoreRequest } from "./servernode";
import { SubscriptionWithPublicIdentifierReply } from "./servernode";
import { SubscriptionWithPublicIdentifierRequest } from "./servernode";
import { Subscription } from "./servernode";
import { SubscriptionRequest } from "./servernode";
import { SubscribeReply } from "./servernode";
import { SubscribeRequest } from "./servernode";
import { RestoreStateReply } from "./servernode";
import { RestoreStateRequest } from "./servernode";
import { WithdrawReply } from "./servernode";
import { WithdrawRequest } from "./servernode";
import { ResolveTransferRequest } from "./servernode";
import { ResolveTransferReply } from "./servernode";
import { ConditionalTransferRequest } from "./servernode";
import { CollateralReply } from "./servernode";
import { TransferResquest } from "./servernode";
import { ChannelResquest } from "./servernode";
import { TxHash } from "./servernode";
import { DepositTxRequest } from "./servernode";
import { DepositRequest } from "./servernode";
import { FullChannelState } from "./servernode";
import { SetupReply } from "./servernode";
import { SetupRequest } from "./servernode";
import { RegisteredTransfers } from "./servernode";
import { RegisteredTransfersRequest } from "./servernode";
import { ActiveTransfersRequest } from "./servernode";
import { FullTransferStates } from "./servernode";
import { TransferStatesByRoutingIdRequest } from "./servernode";
import { FullTransferStateOrUndefined } from "./servernode";
import { TransferStateByRoutingIdRequest } from "./servernode";
import { TransferStateReply } from "./servernode";
import { TransfersRequest } from "./servernode";
import { ChannelStateByParticipantsRequest } from "./servernode";
import { FullChannelStates } from "./servernode";
import { FullChannelStateOrUndefined } from "./servernode";
import { ChannelStateRequest } from "./servernode";
import { Status } from "./servernode";
import { TPublicIdentifier } from "./servernode";
import { Configs } from "./servernode";
import { Pong } from "./servernode";
import { Empty } from "./servernode";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service com.vector.ServerNodeService
 */
export interface IServerNodeServiceClient {
    /**
     * @generated from protobuf rpc: GetPing(com.vector.Empty) returns (com.vector.Pong);
     */
    getPing(input: Empty, options?: RpcOptions): Promise<Pong>;
    /**
     * @generated from protobuf rpc: GetConfig(com.vector.Empty) returns (com.vector.Configs);
     */
    getConfig(input: Empty, options?: RpcOptions): Promise<Configs>;
    /**
     * @generated from protobuf rpc: GetStatus(com.vector.TPublicIdentifier) returns (com.vector.Status);
     */
    getStatus(input: TPublicIdentifier, options?: RpcOptions): Promise<Status>;
    /**
     * @generated from protobuf rpc: GetChannelState(com.vector.ChannelStateRequest) returns (com.vector.FullChannelStateOrUndefined);
     */
    getChannelState(input: ChannelStateRequest, options?: RpcOptions): Promise<FullChannelStateOrUndefined>;
    /**
     * @generated from protobuf rpc: GetChannelStates(com.vector.Empty) returns (com.vector.FullChannelStates);
     */
    getChannelStates(input: Empty, options?: RpcOptions): Promise<FullChannelStates>;
    /**
     * @generated from protobuf rpc: GetChannelStateByParticipants(com.vector.ChannelStateByParticipantsRequest) returns (com.vector.FullChannelStateOrUndefined);
     */
    getChannelStateByParticipants(input: ChannelStateByParticipantsRequest, options?: RpcOptions): Promise<FullChannelStateOrUndefined>;
    /**
     * @generated from protobuf rpc: TransferState(com.vector.TransfersRequest) returns (com.vector.TransferStateReply);
     */
    transferState(input: TransfersRequest, options?: RpcOptions): Promise<TransferStateReply>;
    /**
     * @generated from protobuf rpc: GetTransferStateByRoutingId(com.vector.TransferStateByRoutingIdRequest) returns (com.vector.FullTransferStateOrUndefined);
     */
    getTransferStateByRoutingId(input: TransferStateByRoutingIdRequest, options?: RpcOptions): Promise<FullTransferStateOrUndefined>;
    /**
     * @generated from protobuf rpc: GetTransferStatesByRoutingId(com.vector.TransferStatesByRoutingIdRequest) returns (com.vector.FullTransferStates);
     */
    getTransferStatesByRoutingId(input: TransferStatesByRoutingIdRequest, options?: RpcOptions): Promise<FullTransferStates>;
    /**
     * @generated from protobuf rpc: GetActiveTransfers(com.vector.ActiveTransfersRequest) returns (com.vector.FullTransferStates);
     */
    getActiveTransfers(input: ActiveTransfersRequest, options?: RpcOptions): Promise<FullTransferStates>;
    /**
     * rpc GetChannelStates (ChannelStatesRequest) returns (FullTransferStates) {}
     *
     * @generated from protobuf rpc: GetRegisteredTransfers(com.vector.RegisteredTransfersRequest) returns (com.vector.RegisteredTransfers);
     */
    getRegisteredTransfers(input: RegisteredTransfersRequest, options?: RpcOptions): Promise<RegisteredTransfers>;
    /**
     * @generated from protobuf rpc: Setup(com.vector.SetupRequest) returns (com.vector.SetupReply);
     */
    setup(input: SetupRequest, options?: RpcOptions): Promise<SetupReply>;
    /**
     * @generated from protobuf rpc: InternalSetup(com.vector.SetupRequest) returns (com.vector.FullChannelState);
     */
    internalSetup(input: SetupRequest, options?: RpcOptions): Promise<FullChannelState>;
    /**
     * @generated from protobuf rpc: Deposit(com.vector.DepositRequest) returns (com.vector.FullChannelState);
     */
    deposit(input: DepositRequest, options?: RpcOptions): Promise<FullChannelState>;
    /**
     * @generated from protobuf rpc: SendDepositTx(com.vector.DepositTxRequest) returns (com.vector.TxHash);
     */
    sendDepositTx(input: DepositTxRequest, options?: RpcOptions): Promise<TxHash>;
    /**
     * @generated from protobuf rpc: SendDisputeChannelTx(com.vector.ChannelResquest) returns (com.vector.TxHash);
     */
    sendDisputeChannelTx(input: ChannelResquest, options?: RpcOptions): Promise<TxHash>;
    /**
     * @generated from protobuf rpc: SendDefundChannelTx(com.vector.ChannelResquest) returns (com.vector.TxHash);
     */
    sendDefundChannelTx(input: ChannelResquest, options?: RpcOptions): Promise<TxHash>;
    /**
     * @generated from protobuf rpc: SendDisputeTransfer(com.vector.TransferResquest) returns (com.vector.TxHash);
     */
    sendDisputeTransfer(input: TransferResquest, options?: RpcOptions): Promise<TxHash>;
    /**
     * @generated from protobuf rpc: SendDefundTransfer(com.vector.TransferResquest) returns (com.vector.TxHash);
     */
    sendDefundTransfer(input: TransferResquest, options?: RpcOptions): Promise<TxHash>;
    /**
     * @generated from protobuf rpc: SendRequestCollateral(com.vector.DepositRequest) returns (com.vector.CollateralReply);
     */
    sendRequestCollateral(input: DepositRequest, options?: RpcOptions): Promise<CollateralReply>;
    /**
     * @generated from protobuf rpc: CreateTransfer(com.vector.ConditionalTransferRequest) returns (com.vector.ResolveTransferReply);
     */
    createTransfer(input: ConditionalTransferRequest, options?: RpcOptions): Promise<ResolveTransferReply>;
    /**
     * @generated from protobuf rpc: ResolveTransfer(com.vector.ResolveTransferRequest) returns (com.vector.ResolveTransferReply);
     */
    resolveTransfer(input: ResolveTransferRequest, options?: RpcOptions): Promise<ResolveTransferReply>;
    /**
     * @generated from protobuf rpc: Withdraw(com.vector.WithdrawRequest) returns (com.vector.WithdrawReply);
     */
    withdraw(input: WithdrawRequest, options?: RpcOptions): Promise<WithdrawReply>;
    /**
     * @generated from protobuf rpc: RestoreState(com.vector.RestoreStateRequest) returns (com.vector.RestoreStateReply);
     */
    restoreState(input: RestoreStateRequest, options?: RpcOptions): Promise<RestoreStateReply>;
    /**
     *   [ChannelRpcMethods.chan_restoreState]: FullChannelState;
     *   { schema: { body: NodeParams.RestoreStateSchema, response: NodeResponses.RestoreStateSchema } },
     *   NodeResponses.RestoreState
     *
     * @generated from protobuf rpc: Subscribe(com.vector.SubscribeRequest) returns (com.vector.SubscribeReply);
     */
    subscribe(input: SubscribeRequest, options?: RpcOptions): Promise<SubscribeReply>;
    /**
     *   [ChannelRpcMethods.chan_subscribe]: { event: string; once: boolean };
     *   body: NodeParams.RegisterListenerSchema
     *
     * rpc GetUrl (GetUrlRequest) returns (ListenerSchemaReply) {}
     *
     * @generated from protobuf rpc: GetSubscription(com.vector.SubscriptionRequest) returns (com.vector.Subscription);
     */
    getSubscription(input: SubscriptionRequest, options?: RpcOptions): Promise<Subscription>;
    /**
     * @generated from protobuf rpc: GetSubscriptionWithOnlyPublicIdentifier(com.vector.SubscriptionWithPublicIdentifierRequest) returns (com.vector.SubscriptionWithPublicIdentifierReply);
     */
    getSubscriptionWithOnlyPublicIdentifier(input: SubscriptionWithPublicIdentifierRequest, options?: RpcOptions): Promise<SubscriptionWithPublicIdentifierReply>;
    /**
     *  NodeParams.GetListenerSchema,
     *
     * @generated from protobuf rpc: ClearStore(com.vector.ClearStoreRequest) returns (com.vector.ClearStoreReply);
     */
    clearStore(input: ClearStoreRequest, options?: RpcOptions): Promise<ClearStoreReply>;
    /**
     * @generated from protobuf rpc: CreateNode(com.vector.CreateNodeRequest) returns (com.vector.CreateNodeReply);
     */
    createNode(input: CreateNodeRequest, options?: RpcOptions): Promise<CreateNodeReply>;
    /**
     * @generated from protobuf rpc: EthProvider(com.vector.EthProviderRequest) returns (com.vector.EthProviderReply);
     */
    ethProvider(input: EthProviderRequest, options?: RpcOptions): Promise<EthProviderReply>;
}
/**
 * @generated from protobuf service com.vector.ServerNodeService
 */
export class ServerNodeServiceClient implements IServerNodeServiceClient, ServiceInfo {
    typeName = ServerNodeService.typeName;
    methods = ServerNodeService.methods;
    options = ServerNodeService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * @generated from protobuf rpc: GetPing(com.vector.Empty) returns (com.vector.Pong);
     */
    getPing(input: Empty, options?: RpcOptions): Promise<Pong> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<Empty, Pong>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetConfig(com.vector.Empty) returns (com.vector.Configs);
     */
    getConfig(input: Empty, options?: RpcOptions): Promise<Configs> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<Empty, Configs>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetStatus(com.vector.TPublicIdentifier) returns (com.vector.Status);
     */
    getStatus(input: TPublicIdentifier, options?: RpcOptions): Promise<Status> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<TPublicIdentifier, Status>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetChannelState(com.vector.ChannelStateRequest) returns (com.vector.FullChannelStateOrUndefined);
     */
    getChannelState(input: ChannelStateRequest, options?: RpcOptions): Promise<FullChannelStateOrUndefined> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ChannelStateRequest, FullChannelStateOrUndefined>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetChannelStates(com.vector.Empty) returns (com.vector.FullChannelStates);
     */
    getChannelStates(input: Empty, options?: RpcOptions): Promise<FullChannelStates> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<Empty, FullChannelStates>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetChannelStateByParticipants(com.vector.ChannelStateByParticipantsRequest) returns (com.vector.FullChannelStateOrUndefined);
     */
    getChannelStateByParticipants(input: ChannelStateByParticipantsRequest, options?: RpcOptions): Promise<FullChannelStateOrUndefined> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ChannelStateByParticipantsRequest, FullChannelStateOrUndefined>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: TransferState(com.vector.TransfersRequest) returns (com.vector.TransferStateReply);
     */
    transferState(input: TransfersRequest, options?: RpcOptions): Promise<TransferStateReply> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<TransfersRequest, TransferStateReply>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetTransferStateByRoutingId(com.vector.TransferStateByRoutingIdRequest) returns (com.vector.FullTransferStateOrUndefined);
     */
    getTransferStateByRoutingId(input: TransferStateByRoutingIdRequest, options?: RpcOptions): Promise<FullTransferStateOrUndefined> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<TransferStateByRoutingIdRequest, FullTransferStateOrUndefined>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetTransferStatesByRoutingId(com.vector.TransferStatesByRoutingIdRequest) returns (com.vector.FullTransferStates);
     */
    getTransferStatesByRoutingId(input: TransferStatesByRoutingIdRequest, options?: RpcOptions): Promise<FullTransferStates> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<TransferStatesByRoutingIdRequest, FullTransferStates>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetActiveTransfers(com.vector.ActiveTransfersRequest) returns (com.vector.FullTransferStates);
     */
    getActiveTransfers(input: ActiveTransfersRequest, options?: RpcOptions): Promise<FullTransferStates> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ActiveTransfersRequest, FullTransferStates>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * rpc GetChannelStates (ChannelStatesRequest) returns (FullTransferStates) {}
     *
     * @generated from protobuf rpc: GetRegisteredTransfers(com.vector.RegisteredTransfersRequest) returns (com.vector.RegisteredTransfers);
     */
    getRegisteredTransfers(input: RegisteredTransfersRequest, options?: RpcOptions): Promise<RegisteredTransfers> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<RegisteredTransfersRequest, RegisteredTransfers>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: Setup(com.vector.SetupRequest) returns (com.vector.SetupReply);
     */
    setup(input: SetupRequest, options?: RpcOptions): Promise<SetupReply> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<SetupRequest, SetupReply>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: InternalSetup(com.vector.SetupRequest) returns (com.vector.FullChannelState);
     */
    internalSetup(input: SetupRequest, options?: RpcOptions): Promise<FullChannelState> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<SetupRequest, FullChannelState>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: Deposit(com.vector.DepositRequest) returns (com.vector.FullChannelState);
     */
    deposit(input: DepositRequest, options?: RpcOptions): Promise<FullChannelState> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<DepositRequest, FullChannelState>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: SendDepositTx(com.vector.DepositTxRequest) returns (com.vector.TxHash);
     */
    sendDepositTx(input: DepositTxRequest, options?: RpcOptions): Promise<TxHash> {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<DepositTxRequest, TxHash>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: SendDisputeChannelTx(com.vector.ChannelResquest) returns (com.vector.TxHash);
     */
    sendDisputeChannelTx(input: ChannelResquest, options?: RpcOptions): Promise<TxHash> {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ChannelResquest, TxHash>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: SendDefundChannelTx(com.vector.ChannelResquest) returns (com.vector.TxHash);
     */
    sendDefundChannelTx(input: ChannelResquest, options?: RpcOptions): Promise<TxHash> {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ChannelResquest, TxHash>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: SendDisputeTransfer(com.vector.TransferResquest) returns (com.vector.TxHash);
     */
    sendDisputeTransfer(input: TransferResquest, options?: RpcOptions): Promise<TxHash> {
        const method = this.methods[17], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<TransferResquest, TxHash>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: SendDefundTransfer(com.vector.TransferResquest) returns (com.vector.TxHash);
     */
    sendDefundTransfer(input: TransferResquest, options?: RpcOptions): Promise<TxHash> {
        const method = this.methods[18], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<TransferResquest, TxHash>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: SendRequestCollateral(com.vector.DepositRequest) returns (com.vector.CollateralReply);
     */
    sendRequestCollateral(input: DepositRequest, options?: RpcOptions): Promise<CollateralReply> {
        const method = this.methods[19], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<DepositRequest, CollateralReply>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: CreateTransfer(com.vector.ConditionalTransferRequest) returns (com.vector.ResolveTransferReply);
     */
    createTransfer(input: ConditionalTransferRequest, options?: RpcOptions): Promise<ResolveTransferReply> {
        const method = this.methods[20], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ConditionalTransferRequest, ResolveTransferReply>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: ResolveTransfer(com.vector.ResolveTransferRequest) returns (com.vector.ResolveTransferReply);
     */
    resolveTransfer(input: ResolveTransferRequest, options?: RpcOptions): Promise<ResolveTransferReply> {
        const method = this.methods[21], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ResolveTransferRequest, ResolveTransferReply>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: Withdraw(com.vector.WithdrawRequest) returns (com.vector.WithdrawReply);
     */
    withdraw(input: WithdrawRequest, options?: RpcOptions): Promise<WithdrawReply> {
        const method = this.methods[22], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<WithdrawRequest, WithdrawReply>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: RestoreState(com.vector.RestoreStateRequest) returns (com.vector.RestoreStateReply);
     */
    restoreState(input: RestoreStateRequest, options?: RpcOptions): Promise<RestoreStateReply> {
        const method = this.methods[23], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<RestoreStateRequest, RestoreStateReply>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     *   [ChannelRpcMethods.chan_restoreState]: FullChannelState;
     *   { schema: { body: NodeParams.RestoreStateSchema, response: NodeResponses.RestoreStateSchema } },
     *   NodeResponses.RestoreState
     *
     * @generated from protobuf rpc: Subscribe(com.vector.SubscribeRequest) returns (com.vector.SubscribeReply);
     */
    subscribe(input: SubscribeRequest, options?: RpcOptions): Promise<SubscribeReply> {
        const method = this.methods[24], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<SubscribeRequest, SubscribeReply>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     *   [ChannelRpcMethods.chan_subscribe]: { event: string; once: boolean };
     *   body: NodeParams.RegisterListenerSchema
     *
     * rpc GetUrl (GetUrlRequest) returns (ListenerSchemaReply) {}
     *
     * @generated from protobuf rpc: GetSubscription(com.vector.SubscriptionRequest) returns (com.vector.Subscription);
     */
    getSubscription(input: SubscriptionRequest, options?: RpcOptions): Promise<Subscription> {
        const method = this.methods[25], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<SubscriptionRequest, Subscription>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: GetSubscriptionWithOnlyPublicIdentifier(com.vector.SubscriptionWithPublicIdentifierRequest) returns (com.vector.SubscriptionWithPublicIdentifierReply);
     */
    getSubscriptionWithOnlyPublicIdentifier(input: SubscriptionWithPublicIdentifierRequest, options?: RpcOptions): Promise<SubscriptionWithPublicIdentifierReply> {
        const method = this.methods[26], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<SubscriptionWithPublicIdentifierRequest, SubscriptionWithPublicIdentifierReply>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     *  NodeParams.GetListenerSchema,
     *
     * @generated from protobuf rpc: ClearStore(com.vector.ClearStoreRequest) returns (com.vector.ClearStoreReply);
     */
    clearStore(input: ClearStoreRequest, options?: RpcOptions): Promise<ClearStoreReply> {
        const method = this.methods[27], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<ClearStoreRequest, ClearStoreReply>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: CreateNode(com.vector.CreateNodeRequest) returns (com.vector.CreateNodeReply);
     */
    createNode(input: CreateNodeRequest, options?: RpcOptions): Promise<CreateNodeReply> {
        const method = this.methods[28], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<CreateNodeRequest, CreateNodeReply>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
    /**
     * @generated from protobuf rpc: EthProvider(com.vector.EthProviderRequest) returns (com.vector.EthProviderReply);
     */
    ethProvider(input: EthProviderRequest, options?: RpcOptions): Promise<EthProviderReply> {
        const method = this.methods[29], opt = this._transport.mergeOptions(options);
        const call = stackIntercept<EthProviderRequest, EthProviderReply>("unary", this._transport, method, opt, input);
        return Promise.resolve(call.then(finished => finished.response));
    }
}
